"""
Weather Forecast Metrics Visualization Script

This script creates publication-quality plots of meteorological forecast verification metrics
using the WeatherBench2 (WB2) style. It reads metric files generated by compute_metrics.py.
"""

from matplotlib import transforms
import numpy as np
import matplotlib.pyplot as plt
import os
import glob
import argparse
from matplotlib.gridspec import GridSpec
from pathlib import Path
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class WeatherBench2Visualizer:
    """Class to create WeatherBench2 style visualizations of forecast metrics."""
    
    def __init__(self, metrics_dir: str, output_dir: str = None):
        """
        Initialize the visualizer.
        
        Args:
            metrics_dir: Directory containing metric files
            output_dir: Directory to save plots (defaults to metrics_dir/plots/)
        """
        self.metrics_dir = Path(metrics_dir)
        self.output_dir = Path(output_dir) if output_dir else self.metrics_dir / 'plots'
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Model configuration matching compute_metrics.py (removed HRES as requested)
        self.model_display_names = ["CNN", "Persistence", "Linear Regression", "T42", "T63"]
        self.model_colors = ["#d62728", "#8c564b", "#9467bd", "#2ca02c", "#ff7f0e"]
        
        # Map display names to file names (must match compute_metrics.py ModelConfig names)
        self.file_name_mapping = {
            "CNN": "CNN",
            "Persistence": "Persistence",
            "Linear Regression": "LinearRegression",  # This matches the ModelConfig name
            "T42": "T42",
            "T63": "T63"
        }
        
        # Metrics to display in order (as requested: RMSE, PC, ACC, PCS, CPA)
        self.ordered_metrics = ["rmse", "pc", "acc", "pcs", "cpa"]
        self.metric_titles = ["RMSE", "PC", "ACC", "PCS", "CPA"]
        
        # Set up plotting style
        self._setup_wb2_style()
    
    def _setup_wb2_style(self):
        """Set up WeatherBench2 plotting style."""
        logger.info("Setting up WeatherBench2 plotting style...")
        
        plt.rcParams['axes.grid'] = True
        plt.rcParams['lines.linewidth'] = 2
        plt.rcParams['figure.facecolor'] = 'white'
        plt.rcParams['axes.facecolor'] = '0.95'
        plt.rcParams['grid.color'] = 'white'
        plt.rcParams['axes.spines.right'] = False
        plt.rcParams['axes.spines.top'] = False
        plt.rcParams['grid.alpha'] = 0.8
        
        # Ensure LaTeX-style fonts for all text in the plots
        plt.rcParams['mathtext.fontset'] = 'stix'
        plt.rcParams['font.family'] = 'STIXGeneral'
        plt.rcParams['font.size'] = 12
    
    def label_panel(self, ax, letter, offset_left=0.0, offset_up=0.08, 
                   prefix='(', postfix=')', fs=14, **font_kwds):
        """
        Add panel labels to subplots.
        
        Args:
            ax: Matplotlib axis
            letter: Panel letter
            offset_left: Left offset for label
            offset_up: Upward offset for label
            prefix: Text before letter
            postfix: Text after letter
            fs: Font size
            **font_kwds: Additional font keywords
        """
        kwds = dict(fontsize=fs, weight='bold')
        kwds.update(font_kwds)
        fig = ax.figure
        trans = ax.transAxes + transforms.ScaledTranslation(-offset_left, offset_up, fig.dpi_scale_trans)
        ax.text(0, 1, prefix + letter + postfix, transform=trans, **kwds)
    
    def get_available_metrics(self):
        """
        Scan the metrics directory to find available metrics.
        
        Returns:
            Set of available metric names
        """
        metric_files = list(self.metrics_dir.glob('*_*.txt'))
        if not metric_files:
            logger.warning(f"No metric files found in {self.metrics_dir}")
            return set()
        
        metrics = set()
        for file in metric_files:
            try:
                # Parse filename: ModelName_metric.txt
                parts = file.name.replace('.txt', '').split('_')
                if len(parts) >= 2:
                    metric_name = parts[-1]  # Take the last part as metric name
                    metrics.add(metric_name)
            except IndexError:
                logger.warning(f"Could not parse metric name from file: {file.name}")
        
        logger.info(f"Found metrics: {sorted(metrics)}")
        return metrics
    
    def get_latitude_coordinates(self):
        """
        Get latitude coordinates from a sample metric file.
        
        Returns:
            Array of latitude values
        """
        metric_files = list(self.metrics_dir.glob('*_*.txt'))
        if not metric_files:
            raise FileNotFoundError(f"No metric files found in {self.metrics_dir}")
        
        # Load first available file to get grid dimensions
        sample_file = metric_files[0]
        logger.info(f"Loading latitude coordinates from: {sample_file.name}")
        
        try:
            sample_data = np.loadtxt(sample_file)
            # Create latitude coordinates (assuming global grid from -90 to 90)
            lats = np.linspace(-90, 90, len(sample_data))
            logger.info(f"Generated {len(lats)} latitude points from -90° to 90°")
            return lats
        except Exception as e:
            logger.error(f"Error loading sample file {sample_file}: {e}")
            raise
    
    def load_metric_data(self, model_file_name, metric_name):
        """
        Load metric data for a specific model and metric.
        
        Args:
            model_file_name: File name of the model
            metric_name: Name of the metric
            
        Returns:
            Numpy array of metric values or None if file doesn't exist
        """
        file_path = self.metrics_dir / f"{model_file_name}_{metric_name}.txt"
        
        if not file_path.exists():
            logger.warning(f"File not found: {file_path}")
            return None
        
        try:
            data = np.loadtxt(file_path)
            logger.debug(f"Loaded {metric_name} data for {model_file_name}: shape {data.shape}")
            return data
        except Exception as e:
            logger.error(f"Error loading {file_path}: {e}")
            return None
    
    def create_combined_plot(self, figsize=(18, 12), save_formats=None):
        """
        Create the combined metrics comparison plot.
        
        Args:
            figsize: Figure size tuple
            save_formats: List of formats to save (default: ['pdf'])
            
        Returns:
            Matplotlib figure object
        """
        if save_formats is None:
            save_formats = ['pdf']
        
        logger.info("Creating combined metrics plot...")
        
        # Get latitude coordinates
        lats = self.get_latitude_coordinates()
        
        # Verify metrics are available
        available_metrics = self.get_available_metrics()
        metrics_to_plot = [m for m in self.ordered_metrics if m in available_metrics]
        
        if not metrics_to_plot:
            raise ValueError(f"No metrics found to plot. Available: {available_metrics}")
        
        logger.info(f"Plotting metrics: {metrics_to_plot}")
        
        # Calculate subplot layout: a), b) in top row, c), d), e) in bottom row
        nrows, ncols = 2, 3
        
        # Create figure with subplots
        fig, axes = plt.subplots(nrows, ncols, figsize=figsize)
        axes = axes.flatten()
        
        # Storage for legend
        legend_lines = []
        legend_labels = []
        
        # Create subplots for each metric
        for i, (metric, title) in enumerate(zip(metrics_to_plot, self.metric_titles[:len(metrics_to_plot)])):
            ax = axes[i]
            
            logger.info(f"  Plotting {metric} in subplot {i+1}")
            
            # Plot each model's data for this metric
            for display_name, color in zip(self.model_display_names, self.model_colors):
                file_name = self.file_name_mapping[display_name]
                
                # Load metric data
                data = self.load_metric_data(file_name, metric)
                
                if data is not None:
                    # Plot line
                    line, = ax.plot(lats, data, color=color, alpha=0.9, 
                                  linewidth=2.5, label=display_name)
                    
                    # Store line for legend (only for the first subplot)
                    if i == 0:
                        legend_lines.append(line)
                        legend_labels.append(display_name)
                else:
                    logger.warning(f"No data for {display_name} - {metric}")
            
            # Configure subplot
            self._configure_subplot(ax, metric, title, lats)
            
            # Add panel label
            panel_letters = ['a', 'b', 'c', 'd', 'e']
            if i < len(panel_letters):
                self.label_panel(ax, panel_letters[i])
        
        # Hide unused subplots (only the top-right one)
        for i in range(len(metrics_to_plot), len(axes)):
            axes[i].set_visible(False)
        
        # Create legend
        if legend_lines:
            fig.legend(legend_lines, legend_labels, 
                      loc='lower center', 
                      bbox_to_anchor=(0.5, -0.05),
                      ncol=len(legend_labels),
                      fontsize=16,
                      frameon=True,
                      facecolor='white',
                      edgecolor='gray',
                      columnspacing=2.0)
        
        # Adjust layout
        plt.tight_layout()
        plt.subplots_adjust(hspace=0.3)  # Add vertical spacing between rows
        plt.subplots_adjust(bottom=0.15)  # Make room for legend
        
        # Save figure in requested formats
        for fmt in save_formats:
            output_file = self.output_dir / f"combined_metrics_comparison_wb2_style.{fmt}"
            logger.info(f"Saving plot to: {output_file}")
            
            plt.savefig(output_file, bbox_inches='tight', dpi=300, facecolor='white')
        
        logger.info("Combined plot created successfully!")
        return fig
    
    def _configure_subplot(self, ax, metric, title, lats):
        """
        Configure individual subplot appearance.
        
        Args:
            ax: Matplotlib axis
            metric: Metric name
            title: Title for the subplot
            lats: Latitude coordinates
        """
        # Set title
        ax.set_title(title, fontsize=18, fontweight='bold', pad=15)
        
        # Set labels
        ax.set_xlabel('Latitude', fontsize=14, fontweight='normal')
        
        # Set y-label based on metric type
        if metric == 'rmse':
            ax.set_ylabel('RMSE [K]', fontsize=14, fontweight='normal')
        elif metric == 'pc':
            ax.set_ylabel('PC [K]', fontsize=14, fontweight='normal')
        elif metric in ['pcs', 'cpa', 'acc']:
            ax.set_ylabel(f'{metric.upper()} [-]', fontsize=14, fontweight='normal')
        else:
            ax.set_ylabel(metric.upper(), fontsize=14, fontweight='normal')
        
        # Set latitude ticks with proper formatting
        lat_ticks = [-90, -60, -30, 0, 30, 60, 90]
        ax.set_xticks(lat_ticks)
        ax.set_xticklabels([
            f'{abs(x)}°{"S" if x < 0 else "N" if x > 0 else ""}' 
            for x in lat_ticks
        ])
        ax.tick_params(axis='both', which='major', labelsize=12)
        
        # Set x-limits to show full latitude range
        ax.set_xlim(-90, 90)
        
        # Set y-limits based on metric type for better visualization
        if metric == 'pcs':
            ax.set_ylim(-0.1, 1.1)
        elif metric == 'cpa':
            ax.set_ylim(0.4, 1.05)
        elif metric == 'acc':
            ax.set_ylim(-0.1, 1.1)
        
        # Add subtle grid
        ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
        
        # Add padding
        ax.margins(x=0.01, y=0.05)
    
    def create_individual_plots(self, save_formats=None):
        """
        Create individual plots for each metric.
        
        Args:
            save_formats: List of formats to save (default: ['pdf', 'png'])
        """
        if save_formats is None:
            save_formats = ['pdf', 'png']
        
        logger.info("Creating individual metric plots...")
        
        # Get latitude coordinates
        lats = self.get_latitude_coordinates()
        available_metrics = self.get_available_metrics()
        
        for metric in self.ordered_metrics:
            if metric not in available_metrics:
                logger.warning(f"Skipping {metric} - not found in available metrics")
                continue
            
            logger.info(f"Creating plot for {metric}")
            
            # Create figure
            fig, ax = plt.subplots(figsize=(12, 8))
            
            # Plot each model
            for display_name, color in zip(self.model_display_names, self.model_colors):
                file_name = self.file_name_mapping[display_name]
                data = self.load_metric_data(file_name, metric)
                
                if data is not None:
                    ax.plot(lats, data, color=color, alpha=0.9, 
                           linewidth=3, label=display_name)
            
            # Configure plot
            metric_title = self.metric_titles[self.ordered_metrics.index(metric)]
            self._configure_subplot(ax, metric, metric_title, lats)
            
            # Add legend
            ax.legend(fontsize=14, frameon=True, facecolor='white', 
                     edgecolor='gray', loc='best')
            
            plt.tight_layout()
            
            # Save in requested formats
            for fmt in save_formats:
                output_file = self.output_dir / f"{metric}_comparison.{fmt}"
                plt.savefig(output_file, bbox_inches='tight', dpi=300, facecolor='white')
                logger.info(f"Saved {metric} plot to: {output_file}")
            
            plt.close(fig)
        
        logger.info("Individual plots created successfully!")


def main():
    """Main function to create visualizations."""
    
    # Default paths based on your metric computation script
    metrics_dir = "./temp_wb1/metrics/"
    output_dir = None  # Will default to metrics_dir/plots/
    
    logger.info(f"Metrics directory: {metrics_dir}")
    logger.info(f"Output directory: {output_dir or 'auto (metrics_dir/plots)'}")
    
    try:
        # Create visualizer
        visualizer = WeatherBench2Visualizer(metrics_dir, output_dir)
        
        # Create combined plot (only PDF output)
        logger.info("Creating combined metrics plot...")
        fig = visualizer.create_combined_plot(save_formats=['pdf'])
        
        # Show the combined plot
        plt.show()
        
        logger.info("Visualization completed successfully!")
        
    except Exception as e:
        logger.error(f"Error creating visualizations: {e}")
        raise


if __name__ == "__main__":
    main()
